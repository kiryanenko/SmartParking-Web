Система мониторинга парковочных мест
====================================
(Веб-приложение)
----------------

https://smart-parking-system.herokuapp.com/


АННОТАЦИЯ
---------

Дипломный проект посвящен разработке системы мониторинга парковочных
мест. При выполнении дипломного проекта, было проведено исследование IoT
технологий в сфере транспортной инфраструктуры. В рамках исследования
был проведен анализ существующих систем. На основании этого был
спроектирован недорогой относительно конкурентов аппаратно-программный
прототип системы мониторинга парковочных мест. Основное назначение
системы заключается в определении наличия свободных парковочных мест и
отображении этих данных пользователям. Данная система позволит
пользователям (водителям) в режиме реального времени получать актуальную
информацию о состоянии парковочных мест.

ABSTRACT
--------

The diploma project is devoted to the development of a monitoring system
for parking places. When carrying out the diploma project, was conducted
research IoT technologies in the field of transport infrastructure. As
part of the research, existing systems were analyzed. Based on this, the
hardware-software prototype of a monitoring system for parking places
was designed inexpensive with respect to competitors. The main purpose
of the system is to determine the availability of parking spaces and
display data for users. This system allows users (drivers) to receive
up-to-date information about status of parking places in real time.

РЕФЕРАТ
-------

Разработан проект «Система мониторинга парковочных мест». Основное
назначение системы заключается в определении наличия свободных
парковочных мест и отображении этих данных пользователям. Данная система
позволит пользователям (водителям) в режиме реального времени получать
актуальную информацию о состоянии парковочных мест. Данная система
состоит из: «МК-подсистемы регистрации свободных парковочных мест»,
вычислительного хаба и сервера.

«МК-подсистема регистрации свободных парковочных мест» фиксирует наличие
свободных парковочных мест. К микроконтроллеру подключаются сенсоры,
каждый из которых следит за своим парковочным местом. Через радиомодуль
RFM95W информация о состоянии парковочных мест (свободно / занято)
передается в вычислительный хаб, для последующей обработки. Реализована
функция оплаты парковочного места, с отображением на дисплее и
подтверждением оплаты с клавиатуры.

Основное назначение вычислительного хаба, состоит в осуществлении
взаимодействия сервера, датчиков «МК-подсистема регистрации свободных
парковочных мест» и других компонентов системы.

Сервер осуществляет сбор данных с датчиков «МК-подсистема регистрации
свободных парковочных», управление всеми компонентами системы и вывод
данных пользователям об актуальном состоянии парковочных мест

Материалы по дипломному проекту представлены в виде графической части,
приложения с отлаженным программным кодом и расчетно-пояснительной
записки.

ОПРЕДЕЛЕНИЯ, ОБОЗНАЧЕНИЯ И СОКРАЩЕНИЯ
-------------------------------------

- БС - беспроводная сеть
- БД - база данных
- МК - микроконтроллер
- МКПМ - модуль контроля парковочного места
- МКПРСПМ - МК-подсистема регистрации свободных парковочных мест
- ОС - операционная система
- ПМ - парковочное место
- ПО - программное обеспечение
- СМПМ - система мониторинга парковочных мест
- СУБД - система управления базами данных
- ТС - транспортное средство
- IoT - internet of things
- LoRa - Long Range, метод модуляции в беспроводных сетях
- MQTT - message queue telemetry transport
- RoR - Ruby on Rails

СОДЕРЖАНИЕ
----------

[ВВЕДЕНИЕ](#ВВЕДЕНИЕ)

[Анализ требований к СМПМ](#Анализ-требований-к-СМПМ)

[Разработка диаграммы вариантов использований](#Разработка-диаграммы-вариантов-использований)

[Описание и структура СМПМ](#Описание-и-структура-СМПМ)

[Описание функциональной схемы СМПМ](#Описание-функциональной-схемы-СМПМ)

[Разработка сервера](#Разработка-сервера)

[Анализ задания и выбор технологий](#Анализ-задания-и-выбор-технологий)

[Анализ способа хранения данных](#Анализ-способа-хранения-данных)

[Формы интерфейса](#Формы-интерфейса)

[Алгоритм выдачи парковочных мест](#Алгоритм-выдачи-парковочных-мест)

[Автоматизация развертывания серверного ПО](#Автоматизация-развертывания-серверного-ПО)

[Балансировка нагрузки](#Балансировка-нагрузки)

[Тестирование СМПМ](#Тестирование-СМПМ)

[ЗАКЛЮЧЕНИЕ](#ЗАКЛЮЧЕНИЕ)

[Приложение Б. Формы интерфейсов](/docs/Приложение%20Б.%20Формы%20интерфейсов.pdf)

[Приложение В. Тестирование](/docs/Приложение%20В.%20Тестирование%20СMПМ.pdf)

[Приложение Г. Руководство пользователя](/docs/Приложение%20Г.%20Руководство%20пользователя.pdf)



ВВЕДЕНИЕ
--------

Дипломный проект «Система мониторинга парковочных мест» выполняется на
основании учебного плана кафедры ИУ6 с исходными данными, заданными в
техническом задании. Целью работы является проектирование системы
мониторинга парковочных мест.

Формирование специализированных зон для стоянки автотранспорта началось
почти одновременно с появлением первых автомобилей. Число машин
стремительно растет и для решения возникнувшей проблемы ограниченности
парковочных мест начали внедрять современные технологии.

Основным направлением развития являются «умные» датчики парковки. Такие
датчики встраиваются в дорожное полотно на места парковок и отслеживают
свободно ли машиноместо над ними, отдавая данные в общую систему.
Используя сеть таких датчиков, формируется карта парковок, состояния
которых рассылается пользователям на улицах с помощью специальных табло
или мобильного приложения.

Такая система позволяет решить следующие задачи:
-   сокращение очередей и времени поиска свободного места на парковке;
-   организация оптимального движения транспортных средств и пешеходов
    на парковке;
-   визуальное оповещение о количестве свободных мест в реальном времени
    с помощью информационных табло или на веб-портале;
-   оптимизация работы парковочного пространства.

В ходе данной работы была спроектирована «Система мониторинга
парковочных мест». Основное назначение системы заключается в определении
наличия свободных парковочных мест и отображении этих данных
пользователям. Данная система позволит пользователям (водителям) в
режиме реального времени получать актуальную информацию о состоянии
парковочных мест. Данная система состоит из: «МК-подсистемы регистрации
свободных парковочных мест», вычислительного хаба и сервера.


Анализ требований к СМПМ
========================

Разработка диаграммы вариантов использований
--------------------------------------------

Основное назначение СМПМ заключается в определении наличия свободных
парковочных мест и отображении этих данных пользователям. Данная система
позволяет пользователям (водителям) в режиме реального времени получать
актуальную информацию о состоянии парковочных мест.

Для уточнения требований к функционированию системы необходимо
определить варианты её использования при помощи диаграммы вариантов
использования. Система взаимодействует с двумя видами действующих лиц:
пользователь (водитель) и владелец стоянки. Соответствующие диаграммы
для этих лиц показаны на рисунках 5 и 6.

![Диаграмма вариантов использований для пользователя](/docs/Diagram_of_usage_options_for_the_user.svg)

Рисунок 5 - Диаграмма вариантов использований для пользователя

![Диаграмма вариантов использований для владельца стоянки](/docs/Diagram_of_usage_options_for_the_owner.svg)

Рисунок 6 - Диаграмма вариантов использований для владельца стоянки

Описание и структура СМПМ
-------------------------

На рисунке 7 представлена структурная схема системы мониторинга
парковочных мест. Система мониторинга парковочных мест состоит из
следующих блоков:
-   МК-подсистема регистрирования свободных парковочных мест (МКПРСПМ),
-   вычислительный хаб,
-   сервер.

Датчики МКПРСПМ служат для фиксации наличия свободных парковочных мест и
оплаты. МКПРСПМ формирует пакеты с информацией о свободных парковочных
местах и передаёт их на вычислительный хаб по беспроводной сети LoRaWAN.

Вычислительный хаб, представленный в виде микрокомпьютера Raspberry Pi,
необходим для осуществления взаимодействия сервера, МКПРСПМ и других
компонентов системы. Хаб выполняет приём пакетов, переданных с МКПРСПМ,
формирует пакеты MQTT и передает их на сервер по сети интернет. Обратно
от сервера хаб получает команды управления МКПРСПМ, которые также
передаются по сети LoRaWAN, на МК-подсистемы.

Пользователь с мобильного устройства на платформе Android с
установленным приложением сможет посмотреть карту с указанием
местоположений свободных парковочных мест. Мобильное приложение получает
данные о парковочных местах с помощью API-сервисов, предоставляемых
сервером.

![Структурная схема системы мониторинга парковочных мест](/docs/Structural_scheme.svg)

Рисунок 7 - Структурная схема системы мониторинга парковочных мест

Веб-клиент, предоставляет карту со свободными парковочными местами.
Также для владельцев стоянок, предоставляется возможность для управления
за парковочными местами: изменение тарифного плана, настройка параметров
МКПСРСПМ.

Описание функциональной схемы СМПМ
----------------------------------

На рисунке Рисунок 8 показана функциональная схема СМПМ. Система
работает следующим образом. В МКПРСПМ сигнал о состоянии парковочного
места приходит от сенсора присутствия автомобиля, после чего МК
ATMEGA328 формирует пакеты и отправляет их через радиомодуль RFM95 по
сети LoRaWAN на вычислительный хаб. Также по сети LoRaWAN МКРСППМ может
принять команды для изменения настроечных параметров.

Вычислительный хаб служит для осуществления взаимодействия сервера,
МКПРСПМ и других компонентов системы. Хаб через радиомодуль RFM95
принимает пакеты, переданные с МКПРСПМ, формирует MQTT пакеты и передает
их на сервер и на другие компоненты системы. Данные внутри MQTT пакетов
передаются в формате JSON. Обратно от сервера хаб получает команды
управления МКПРСПМ, которые также передаются по сети LoRaWAN, на
МК-подсистемы. ПО для вычислительного хаба написано с использованием
фреймворка Qt. На вычислительном хабе может быть установлено серверное
ПО, тем самым хаб сформирует локальную сеть, внутри которой сможет
работать как сервер. MQTT - это легкий протокол для передачи данных,
который идеально подходит для взаимодействия большого количества IoT
устройств. Таким образом, к вычислительному хабу возможно подключить
множество других устройств (например, табло индикации количества
свободных парковочных мест), позволяющие взаимодействовать по протоколу
MQTT.

![Функциональная схема СМПМ](/docs/Functional_diagram.svg)

Рисунок 8 - Функциональная схема СМПМ

Сервер взаимодействует с вычислительным хабом по протоколу MQTT. Для
этого на сервере установлен MQTT брокер Mosquitto. Приложение на
фреймворке Ruby on Rails принимает данные о состоянии ПМ через MQTT
брокер и сохраняет в БД PostgreSQL. Также сервер может управлять
датчиками МКПРСПМ, отправляя команды по протоколу MQTT на вычислительный
хаб. Сервер Nginx является Frontend сервером, он осуществляет раздачу
статики и проксирование запросов на веб-сервер Puma, который уже
взаимодействует с веб-приложением на Ruby on Rails. Веб-приложение для
кэширования использует сервис кэширования Memcached. Для работы Action
Cable, который осуществляет взаимодействие с веб-клиентами по WebSocket,
необходима «key - value» хранилище данных Redis. Чтобы веб-клиент в
режиме реального времени получал данные о состоянии парковочных мест,
данные о парковочных местах в формате JSON периодически отправляются по
протоколу WebSocket.



Разработка сервера
==================

Анализ задания и выбор технологий
---------------------------------

Как показал анализ технического задания, ПО на серверной стороне должен
реализовывать следующий функционал:
-   отображение на карте местоположения стоянок и парковочных мест;
-   выдача актуальных данных о ПМ;
-   бронирование парковочного места;
-   добавление датчиков МКПРСПМ;
-   удалённая настройка датчиков МКПРСПМ;
-   регистрирование стоянок и парковочных мест с указанием
    местоположения на карте;
-   изменение данных о стоянках и парковочных местах;
-   приём MQTT пакетов данных о состоянии ПМ, полученные от
    вычислительного хаба;
-   сохранение данных об изменении состоянии ПМ в БД;
-   регистрация и авторизация пользователей.

Для создания данного ПО для серверной части был использован полноценный,
многоуровневый фреймворк, использующий базы данных, Ruby on Rails,
который основан на архитектуре Модель-Представление-Контроллер
(Model-View-Controller, MVC). Обработка запросов и выдача данных
в контроллерах, предметная область, отраженная в базе данных, -- для
всего этого Rails предоставляет однородную среду разработки на Ruby.
Основным преимуществом языка программирования Ruby и фреймворка Ruby on
Rails считается скорость разработки. Практика показывает, что скорость
разработки проектов на RoR увеличивается на 30 - 40 процентов по
отношению к любому другому языку программирования или фреймворку. В
первую очередь прирост скорости разработки определяется обширным набором
готовых к работе штатных инструментов RoR, колоссальным набором готовых
решений в сообществе, языком Ruby и простоте программирования на нем.
Кроме того, в отличие от других фреймворков, в составе RoR есть отличные
средства автоматизированного тестирования, что ускоряет переход проекта
от стадии «программа написана» к стадии «программа работает без ошибок».
Так же следует отметить, что Ruby on Rails обеспечивает лучшую
безопасность проекта. При использовании инструментов RoR исключены
SQL-инъекции и XSS-атаки, все входные параметры экранируется по
умолчанию, выводимые переменные в шаблонах также экранируются.

Согласно анализу требований, на серверной стороне используется следующее ПО:
-   Разработанное веб-приложение на фреймворке Ruby on Rails.
-   Frontend-сервер Nginx, который осуществляет раздачу статических
    файлов и проксирование запросов на веб-сервер Puma,
    взаимодействующий с веб-приложением на Ruby on Rails.
-   MQTT-брокер Mosquitto необходим для реализации MQTT протокола. На
    брокера приходят данные с вычислительных хабов, а веб-приложение их
    считывает.
-   Сервис кэширования Memcached используется веб-приложением для
    кэширования данных.
-   СУБД PostgreSQL используется для хранения данных.
-   СУБД Redis необходим для работы Action Cable, позволяющий
    взаимодействовать с веб-клиентами по WebSocket.
-   Фреймворк Bootstrap v4.1 - это инструментарий с открытым исходным
    кодом для разработки с помощью HTML, CSS и JS. С помощью него
    создаётся адаптивный и интерактивный веб-дизайн.
-   Google Maps APIs для реализации карты парковок.

Анализ способа хранения данных
------------------------------

Существует несколько технологий позволяющих хранить и упорядочивать
информацию. Существует множество систем управления базой данных (СУБД),
проанализировав их, я пришёл к выводу, что наиболее лучшим вариантом
будет использование PostgreSQL, т.к. оно обладает следующими
преимуществами: поддержка БД неограниченного размера, мощные и надёжные
механизмы транзакций и репликации, расширяемая система встроенных языков
программирования, наследование, легкая расширяемость. Также для работы с
картографическими данными имеется расширение PostGIS.

![Схема базы данных](/docs/DB_scheme.png)

На рисунке Е.16 показана разработанная схема базы данных. В таблице
`users` находятся зарегистрированные пользователи системы.

В таблице `parkings` хранятся стоянки. В поле `area` находится массив
координат полигона, который образует территория стоянки. Это необходимо
для отрисовки на карте синего полигона, обозначающего территорию стоянки
(Рисунок 25). Поле `parking_places_count` добавлено с целью
оптимизации выдачи количества парковочных мест, принадлежащих данной
стоянке.

Таблица `sensors` хранит добавленные датчики регистрации свободных
парковочных мест. При добавлении нового датчика для него генерируется
уникальный идентификатор `id`, который необходимо будет указать самому
физическому датчику.

В таблице `parking_places` находятся парковочные места. Поля `booked`,
`free` и `connected` отвечают за текущее состояние ПМ. Поле `can_book`
отвечает за возможность онлайн бронирования этого ПМ.

В таблице `parking_states` хранится история изменения состояний
парковочного места. Таблица служит для сбора статистических данных. При
приходе одинокого состояния с прошлым новая запись не добавляется, а
обновляется поле `updated_at`.

Таблица `orders` служит для хранения совершенных заказов пользователей
на бронирование парковочного места. В поле `cost` хранится суммарная
стоимость заказа, в поле `payment` - внесенная сумма пользователем.
Поле `booked_time` хранит время в секундах на сколько было
забронировано ПМ, а `end_time` - время окончания брони. При добавлении
нового заказа поле `active` по умолчанию устанавливается в значение
TRUE, что означает, что заказ в данный момент активен, а после окончании
брони поле `active` устанавливается в значение `FALSE`.

Формы интерфейса
----------------

Для верстки страниц веб-приложения применялся фреймворк Bootstrap v4.0.
Данный фреймворк имеет множество стилей для множества компонентов, с
помощью которых можно быстро реализовать адаптивный, интерактивный
дизайн проекта. Таким образом, используя данный фреймворк обеспечивается
правильное отображение веб-страниц на различных устройствах.

Также для реализации карты, отображающей парковки, использовался Google
Maps APIs. Данное API очень удобное, имеет хорошую документацию и
позволяет реализовывать интерактивные карты, которые хорошо будут
отображаться на различных устройствах.

На рисунке 25 показана главная странице `/`, на которой
пользователю предоставляется карта с указанием местоположений парковок в
данной области. На карте синими областями показана территория стоянки, а
красными маркерами - парковочные места. В правой части находится кнопка
«Меню» при нажатии на которую выдвигается боковая панель с элементами
управления для фильтрации содержимого карты. Более подробнее о формах
интерфейсов смотри приложение Б.

![Главная страница](/docs/media/image27.png)

Рисунок 25 - Главная страница

Алгоритм выдачи парковочных мест
--------------------------------

В Ruby on Rails механизм Action Cable с легкостью интегрирует WebSockets
с остальными частями веб-приложения. Он позволяет писать
функциональность реального времени и является производительным и
масштабируемым. Он представляет полный стек, включая клиентский
фреймворк на JavaScript и серверный фреймворк на Ruby. Этот механизм
использовался для реализации выдачи в реальном времени состояний
парковочных мест на главной странице `/` веб-приложения.

Веб-клиент на главной странице `/` создаёт WebSocket соединение и
подключается к каналу `MapChannel` и для выдачи парковочных мест в
заданной области передаёт следующие параметры запроса: координаты
местоположения, радиус и список фильтров поиска. Сервер нового клиента
подписывает на соответствующий поток (`stream`), по которому периодически
высылаются состояния парковочных в заданной области.

В БД для оптимизации поиска в таблицах на всех полях, по которым
осуществляется поиск были навешаны соответствующие BTREE индексы. А
также для пространственных координат в таблицах парковочных мест и
стоянок были созданы GIST индексы.

Также для оптимизации производительности карта была поделена на взаимно
пересекающиеся квадраты. Число точек, по которым могут быть построены
квадраты, ограничено и размеры самих квадрат также ограничены и
определяются, исходя из масштаба, определяемого по переданному радиусу.
Таким образом, количество таких квадратов ограничено и, следовательно,
исчезает уникальность в запросах пользователей, клиентов можно
подписывать на общие потоки и появляется возможность кэширования запросов.

Масштаб `s` вычисляется по формуле:

![](https://latex.codecogs.com/gif.latex?$$s&space;=&space;ceil(log_2{\frac{2*r_{src}}{a_{min}}})$$)

где, `r_src` - радиус из параметра запроса:

`a_min` - константа, минимальная сторона квадрата, равная 0,01.

Сторона квадрата `a` определяется формулой:

![](https://latex.codecogs.com/gif.latex?$$a=a_{min}*2^{s}$$)

Для расчета координат центра квадрата потребуются промежуточное
вычисление `x_a` и `y_a` - координаты с шагом равным стороне:

<a href="https://www.codecogs.com/eqnedit.php?latex=$$\left\{\begin{matrix}&space;x_{a}&space;=&space;floor(\frac{x_{src}}{0,5*a})\\&space;y_{a}&space;=&space;floor(\frac{y_{src}}{0,5*a})\\&space;\end{matrix}\right.$$" target="_blank"><img src="https://latex.codecogs.com/gif.latex?$$\left\{\begin{matrix}&space;x_{a}&space;=&space;floor(\frac{x_{src}}{0,5*a})\\&space;y_{a}&space;=&space;floor(\frac{y_{src}}{0,5*a})\\&space;\end{matrix}\right.$$" title="$$\left\{\begin{matrix} x_{a} = floor(\frac{x_{src}}{0,5*a})\\ y_{a} = floor(\frac{y_{src}}{0,5*a})\\ \end{matrix}\right.$$" /></a>

где, `x_src` и `y_src` - координаты местоположения из параметра запроса.

Далее находятся координаты четырёх квадратов `x_sq`, `x_sq'` и
`y_sq`, `y_sq'` вокруг исходных координат `x_src` и `y_src`.
И требуется определить координаты `x` и `y` квадрата ближайшего к
исходным координатам:

<a href="https://www.codecogs.com/eqnedit.php?latex=$$\left\{&space;\begin{matrix}&space;x&space;=&space;\left\lbrack&space;\begin{matrix}&space;x_{sq}&space;=&space;\frac{a*x_{a}}{2}&space;\\&space;x_{sq}'&space;=&space;\frac{a*{(x}_{a}&space;&plus;&space;1)}{2}&space;\\&space;\end{matrix}&space;\right.\&space;\\&space;y&space;=&space;\left\lbrack&space;\begin{matrix}&space;y_{sq}&space;=&space;\frac{a*y_{a}}{2}&space;\\&space;y_{sq}'&space;=&space;\frac{a*{(y}_{a}&space;&plus;&space;1)}{2}&space;\\&space;\end{matrix}&space;\right.\&space;\\&space;\end{matrix}&space;\right.$$" target="_blank"><img src="https://latex.codecogs.com/gif.latex?$$\left\{&space;\begin{matrix}&space;x&space;=&space;\left\lbrack&space;\begin{matrix}&space;x_{sq}&space;=&space;\frac{a*x_{a}}{2}&space;\\&space;x_{sq}'&space;=&space;\frac{a*{(x}_{a}&space;&plus;&space;1)}{2}&space;\\&space;\end{matrix}&space;\right.\&space;\\&space;y&space;=&space;\left\lbrack&space;\begin{matrix}&space;y_{sq}&space;=&space;\frac{a*y_{a}}{2}&space;\\&space;y_{sq}'&space;=&space;\frac{a*{(y}_{a}&space;&plus;&space;1)}{2}&space;\\&space;\end{matrix}&space;\right.\&space;\\&space;\end{matrix}&space;\right.$$" title="$$\left\{ \begin{matrix} x = \left\lbrack \begin{matrix} x_{sq} = \frac{a*x_{a}}{2} \\ x_{sq}' = \frac{a*{(x}_{a} + 1)}{2} \\ \end{matrix} \right.\ \\ y = \left\lbrack \begin{matrix} y_{sq} = \frac{a*y_{a}}{2} \\ y_{sq}' = \frac{a*{(y}_{a} + 1)}{2} \\ \end{matrix} \right.\ \\ \end{matrix} \right.$$" /></a>

На рисунке 26 приводится схема алгоритма подключения нового
клиента к каналу `MapChannel` для периодической выдачи в реальном
времени актуальных данных о состоянии парковочных мест.

Было проведено нагрузочное тестирование для данного алгоритма: при
заполненной БД (13582 записи) RPS составил 846 запросов в секунду (более
подробнее см. Приложение В).

После формирования подписки клиента заданный квадрат добавляется в
список обслуживаемых квадратов. Отдельный поток в бесконечном цикле для
каждого квадрата получает данные о состоянии парковочных мест и
рассылает их в соответствующем потоке (stream). В листинге 2 приводится
класса `MapService`, который осуществляет данное действие.

![Схема алгоритма подключения нового клиента к каналу MapChannel](/docs/algorithm.svg)

Рисунок 26 - Схема алгоритма подключения нового клиента к каналу `MapChannel`

Листинг 2 - Файл «/app/services/map\_service.rb»
```ruby
require 'singleton'

class MapService
  include Singleton

  def initialize
    @map_clients = Hash.new
    @squares = Hash.new
    @squares_m = Mutex.new
    run
  end

  def add_square(square)
    @squares_m.synchronize do
      if @squares.has_key? square.stream
        sq = @squares[square.stream]
        sq[:count] += 1
      else
        @squares[square.stream] = {square: square, count: 1}
      end
    end
  end

  def remove_square(square)
    @squares_m.synchronize do
      sq = @squares[square.stream]
      sq[:count] -= 1
      if sq[:count] <= 0
        @squares.delete square.stream
      end
    end
  end

  private
  def run
    Thread.new do
      loop do
        before = Time.now

        begin
          values = []
          @squares_m.synchronize { values = @squares.values.dup }
          values.each do |value|
            value[:square].broadcast
          end
          ParkingPlace.unset_changed
        rescue Exception => e
          Rails.logger.error e.message
          Rails.logger.error e.backtrace
        end

        sleep_time = Rails.configuration.map_sending_period - (Time.now - before)
        sleep sleep_time if sleep_time > 0
      end
    end
  end
end
```


Автоматизация развертывания серверного ПО
-----------------------------------------

Для автоматизации развертывания ПО на боевых серверах используется среда
виртуализации Docker, а также Docker-compose - инструмент для запуска
многоконтейнерных приложений. Docker позволяет «упаковать» приложение со
всем его окружением и зависимостями в контейнер, который может быть
перенесён на любую Linux -систему, а также предоставляет среду по
управлению контейнерами. Таким образом, для разворачивания серверного ПО
достаточно чтобы на сервере с ОС семейства Linux были установлены среда
Docker и инструмент Docker-compose.

Ниже (Листинг 3) представлен Dockerfile - файл с инструкцией по
разворачиванию Docker-контейнера веб-приложения Ruby on Rails:

Листинг 3 - Файл «Dockerfile»
```dockerfile
FROM ruby:2.3
MAINTAINER Kiryanenko Alexander <KiryanenkoAV@gmail.com>

RUN apt-get update &&\
    apt-get install -y \
        build-essential \
        nodejs \
        npm \
        postgresql-contrib \
        git &&\
    npm install yarn -g

RUN mkdir /app
WORKDIR /app

COPY Gemfile ./
RUN bundle install --jobs 20

COPY . .

# Setting env up
ENV RAILS_ENV 'production'
ENV RAKE_ENV 'production'
ENV SECRET_KEY_BASE $(rake secret)

RUN bundle exec rake assets:precompile

EXPOSE 3000

CMD rails db:migrate && bundle exec puma -C config/puma.rb
```

В файле «docker-compose.yml» (Листинг 4) описываются запускаемые
контейнеры: веб-приложения, СУБД PostgreSQL, СУБД Redis, MQTT-брокера
Mosquitto, сервис Memcached и сервера Nginx.

Листинг 4 - Файл «docker-compose.yml»
```yml
version: '2'
services:
  postgres:
    image: mdillon/postgis:9.6-alpine
    environment:
      POSTGRES_USER: smartparking
      POSTGRES_PASSWORD: 123456
    ports:
      - 5432:5432
    volumes:
      - postgres:/var/lib/postgresql/data
    restart: always

  redis:
    image: redis
    command: redis-server
    ports:
      - 6379:6379
    volumes:
      - redis:/data
    restart: always

  mqtt:
    image: ansi/mosquitto
    ports:
      - 1883:1883
    restart: always

  memcached:
      image: memcached:alpine
      ports:
        - 11211:11211

  web:
    depends_on:
      - postgres
      - redis
      - mqtt
      - memcached
    volumes:
      - public:/app/public
      - tmp:/tmp
    build: .
    ports:
      - 3000:3000
    env_file: .env
    environment:
      RAILS_ENV: production
      REDIS_URL: redis://redis:6379/1
      MQTT_URI: mqtt://mqtt
      DB_HOST: postgres
    links:
      - postgres
      - redis
      - mqtt
      - memcached
    restart: always

  nginx:
    image: nginx:alpine
    volumes_from:
      - web
    volumes:
      - ./config/nginx.conf.erb:/etc/nginx/nginx.conf
      - nginx_logs:/etc/nginx/logs/nginx
    depends_on:
      - web
    ports:
      - 80:80
    links:
      - web
    restart: always

volumes:
  redis:
  postgres:
  public:
  tmp:
  nginx_logs:
```

Для развертывания серверного ПО достаточно вбить следующую команду:

    $ docker-compose up

Балансировка нагрузки
---------------------

Балансировка нагрузки необходима в случаях, когда один-единственный
сервер не справляется с возложенными на него задачами в силу возросшего
количества запросов. В Nginx роль балансировщика реализует модуль
HttpUpstreamModule. С помощью облачной платформы Google Cloud была
реализована инфраструктура (Рисунок 27), состоящая из сервера для
балансировки нагрузки между 3-мя backend-серверами, на которых находится
само веб-приложение.

Технические характеристики виртуальных машин:

-   Количество ядер: 1

-   ОЗУ: 3,75 Гб

![Принципиальная схема сети](/docs/Diagram_of_the_network.svg)

Рисунок 27 - Принципиальная схема сети

Ниже (Листинг 5) показан конфигурационный файл Nginx для балансировщика нагрузки:

Листинг 5 - Файл «nginx-balancer.conf»
```
upstream backend {
  ip_hash;
  server 10.142.0.4 max_fails=3 fail_timeout=10s;
  server 10.142.0.5 max_fails=3 fail_timeout=10s;
  server 10.142.0.6 max_fails=3 fail_timeout=10s;
}

server {
  listen 80;
  server_name 0.0.0.0;
  root /app/public;
  allow all;

  location /nginx_status {
    stub_status;
  }

  location /assets/ {
    error_page 404 = @store;
    expires max;
  }

  location @store {
    proxy_store on;
    proxy_store_access user:rw group:rw all:r;
    proxy_pass http://backend;
    proxy_set_header X-Real-IP  $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto http;
    proxy_set_header Host $http_host;
  }

  location / {
    proxy_pass http://backend;
    proxy_next_upstream error timeout invalid_header http_502;
    proxy_set_header X-Real-IP  $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto http;
    proxy_set_header Host $http_host;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "upgrade";
    proxy_redirect off;
  }
}
```

С помощью мониторингового сервиса Datadog была продемонстрирована
балансировка нагрузки с симуляцией падения одного backend-сервера во
время нагрузочного тестирования (рисунки 28, 29). Как
можно видеть при падении одного из backend-серверов (фиолетовый график)
балансировщик (синий график) распределяет нагрузку между оставшимися
backend-серверами (зеленый, желтый график).

![](/docs/media/image30.png)

Рисунок - График RPS на сервере балансировщика (синий) и backend-серверах

![](/docs/media/image31.png)

Рисунок - График нагрузки CPU на сервере балансировщика (синий) и backend-серверах


Тестирование СМПМ
=================

Для проверки требований, предъявленных в техническом задании, в
разработанной системе мониторинга парковочных мест были протестированы
все компоненты системы, а также было проведено комплексное тестирование
системы (Приложение В). Для тестирования МКПРСПМ был собран отладочный
макет, внешний вид которого изображен на рисунке 30.

![](/docs/media/image32.png)

Рисунок 30 - Внешний вид отладочного макета

Также для проверки и анализа данных работоспособности при большой
нагрузки было проведено нагрузочное тестирование. Так, например, RPS для
выдачи парковочных мест (п.п. 5.4) при заполненной БД (13582 записи)
составила 846 запросов в секунду (более подробнее см. в Приложение В).

Для обеспечения качества в ходе дальнейшей разработки для веб-приложения
были написаны 60 автоматизированных теста, покрывающие весь функционал.
Из них 14 модульных теста, 6 интеграционных теста и 40 функциональных
тестов контроллеров.

Результатом проведенного тестирования было установлено, что были
выполнены все предъявляемые требования к разработанному прототипу
системы мониторинга парковочных мест.


ЗАКЛЮЧЕНИЕ
==========

В результате выполнения выпускной квалификационной работы бакалавра был
спроектирован и реализован аппаратно-программный прототип «Системы
мониторинга парковочных мест». Такая система для водителей будет в
режиме реального времени предоставлять актуальные данные о состоянии
парковочных мест. Данная система состоит из МК-подсистемы регистрации
свободных парковочных мест, вычислительного хаба и центрального сервера.

Программное обеспечение для компонентов системы написано преимущественно
в объектном стиле, который обеспечивает интеграцию и удобство для
дальнейшей разработки командой разработчиков.

В ходе выполнения работы было проведено исследование IoTтехнологий в
транспортной инфраструктуре, а также анализ существующих систем.
Разработанная система экономически более выгодна относительно
конкурентных систем.

Все компоненты системы были отлажены и протестированы. Для
разработанного серверного ПО были написаны автоматизированные тесты для
обеспечения качества в ходе дальнейшей разработки. Также был проведен
анализ безопасности системы. Таким образом, разработанная система
соответствует всем требованиям, заявленных в техническом задании.
